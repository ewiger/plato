#!/usr/bin/env python
import os
import sys
import argparse
import logging
import time
import ConfigParser

def extend_sys_path(module_path, folders):
    root_path = os.path.dirname(os.path.dirname(module_path))
    for folder in folders:
        # Prepend path to the modules effectively prioritizing them.
        sys.path.insert(0, os.path.join(root_path, folder))
extend_sys_path(os.path.abspath(__file__), ('lib','src'))

from daemon.runner import DaemonRunner
from plato import getBasicLogger
from plato.schedule import Scheduler


USER_HOME_DIR = os.path.expanduser('~/')
SCHEDULER = 'LOCAL'
APP_NAME = 'plato'
CONF_NAME = APP_NAME + '.conf'
DEBUG = True


logger = getBasicLogger(APP_NAME, logging.DEBUG)
is_interactive = False


class PlatoApp():

    def __init__(self, config_name=CONF_NAME, scheme_name=SCHEDULER):
        self.__state_path = None #  Must be set for get_state_path().
        self.config = ConfigParser.ConfigParser(defaults=self.get_config_vars())
        self.init_config(config_name)
        self.scheduler = Scheduler.create(
            scheme_name, self.state_path, self.config)
        
    def get_config_vars(self):
        '''Mainly defined shared variables with defaults'''
        return dict(
            # Fallback to default folder in user home.
            statepath=os.path.expanduser('~/.' + APP_NAME),
            schedulername=SCHEDULER.lower(),
            )
    
    def init_config(self, config_name):
        # Start with building some defaults.
        # Init/set application options.
        self.config.add_section('app')
        #self.config.set('app', 'statepath', '%(default_statepath)s')
        self.config.set('app', 'scheduler', '%(schedulername)s')   
        # Init/set dameon options.
        self.config.add_section('daemon')
        self.config.set('daemon', 'stdin_path', '/dev/null')
        self.config.set('daemon', 'stdout_path',
                        '/dev/tty' if DEBUG else '/dev/null')
        self.config.set('daemon', 'stderr_path',
                        '/dev/tty' if DEBUG else '/dev/null')
        self.config.set('daemon', 'pidfile_path', 
                        '%(statepath)s' + APP_NAME + '.pid')
        self.config.set('daemon', 'pidfile_timeout', '5')
        self.config.set('daemon', 'sleepping_pause', '10')
        # Init/set scheduler options.
        self.config.add_section('scheduler')
        self.config.set('scheduler', 'isinteractive', str(int(is_interactive)))        
        # Load defaults from .../bin/<APP>.conf
        self.load_config(config_name=config_name)
        # Override with user config which is ~/<APP>.conf
        self.load_config(USER_HOME_DIR, config_name)
        # Assert configuration for correctness.
        self.config.has_section('app')
        assert self.config.get('app', 'statepath') is not None
    
    def load_config(self, config_dir=None, config_name=CONF_NAME):
        '''
        Load configuration from supplied filename. By default configuration
        directory is set to point to '.../bin/<APP>.conf'
        '''
        if config_dir is None:
            config_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(config_dir, config_name)
        if os.path.exists(config_path):
            logger.info('Loading %s' % config_path)
            self.config.read(config_path)

    @property
    def state_path(self):
        if self.__state_path is None:
            # Try to get configuration option.
            self.__state_path = self.config.get('app', 'statepath')
            if not os.path.exists(self.__state_path):
                logger.warn('Creating a missing dir: %s' % self.__state_path)
                os.makedirs(self.__state_path)
        return self.__state_path
    
    @property
    def stdin_path(self):
        '''Part of DaemonRunner protocol'''
        return self.config.get('daemon', 'stdin_path')

    @property
    def stdout_path(self):
        '''Part of DaemonRunner protocol'''
        return self.config.get('daemon', 'stdout_path')
    
    @property
    def stderr_path(self):
        '''Part of DaemonRunner protocol'''
        return self.config.get('daemon', 'stderr_path')
    
    @property    
    def pidfile_path(self):
        '''Part of DaemonRunner protocol'''
        return self.config.get('daemon', 'pidfile_path')
    
    @property
    def pidfile_timeout(self):
        '''Part of DaemonRunner protocol'''
        return self.config.get('daemon', 'pidfile_timeout')

    def step(self):
        self.scheduler.submitt_jobs()
        self.scheduler.process_jobs()
        self.scheduler.runner.forget_job_list()

    def run(self):
        while True:
            self.step()
            # Sleep x seconds.
            sleepping_pause = self.config.getint('daemon', 'sleepping_pause')
            logger.info('Sleeping for %d (sec)..' % sleepping_pause)
            time.sleep(sleepping_pause)


def get_scheduler():
    '''
    Instance application, read configuration in order to construct and 
    return scheduler object.
    '''
    return PlatoApp().scheduler

# Below go function that do actual work based on command line arguments

def run_as_daemon(args):
    plato_app = PlatoApp()
    if not is_interactive:
        plato_app = PlatoApp()
        app_argv = [sys.argv[0], args.action]
        daemon_runner = DaemonRunner(plato_app, app_argv)
        daemon_runner.do_action()
    else:
        plato_app.run()


def run_steps(args):
    plato_app = PlatoApp()
    for index in range(args.times):
        plato_app.step()


def list(args):
    '''List plato registered jobs (not runner's like LSF).'''
    logger.info('listing jobs')
    scheduler = get_scheduler()
    jobs = scheduler.runner.list_jobs('*')
    print jobs


def submit(args):
    logger.info('submit job')
    if not args.batch_name:
        batch_name = os.path.basename(args.command.split()[0])
    info = dict()
    info['command'] = args.command
    if info['command'] == '-':
        # Treat standard input as submission shell line
        lines = [line for line in sys.stdin]
        if len(lines) > 1:
            raise Exception('Multiline command submission is not supported (yet)!')
        info['command'] = lines[0].strip()
    info['queue'] = args.queue if not args.queue else 'default'
    scheduler = get_scheduler()
    job = scheduler.monitor.new_job(batch_name)
    job.info = info
    if not scheduler.submit_job(job):
        logger.error('Failed to submit job: %s' % job)


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('--interactive', action='store_true', default=False)
    subparsers = parser.add_subparsers()
    
    # daemon
    parser_daemon = subparsers.add_parser('daemon')
    parser_daemon.add_argument('action', help="{start, stop, restart}")
    parser_daemon.set_defaults(func=run_as_daemon)

    # run
    parser_run = subparsers.add_parser('run')
    parser_run.add_argument('times', nargs='?', type=int, default=1)
    parser_run.set_defaults(func=run_steps)

    # list 
    parser_list = subparsers.add_parser('list')
    parser_list.set_defaults(func=list)
    
    # submit
    parser_submit = subparsers.add_parser('submit')
    parser_submit.add_argument('--queue', default='default')
    parser_submit.add_argument('--name', dest="batch_name", 
                               help="Job title or batch name")
    parser_submit.add_argument('command')
    parser_submit.set_defaults(func=submit)

    args = parser.parse_args()
    if not args.func:
        parser.print_help()
        exit()

    is_interactive = args.interactive
    args.func(args)

